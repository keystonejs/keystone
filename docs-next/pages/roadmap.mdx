import { Markdown } from '../components/Page';
import { Status } from '../components/Status';
import { SubscribeForm } from '../components/SubscribeForm';

# Roadmap

In 2018 when Keystone 5 was announced, it was a great leap forward from a back-end Node.js CMS platform built with MongoDB, to a modern platform with first class support for GraphQL, PostgreSQL, and more.

Over the last six months, weâ€™ve built around the existing stable core of Keystone 5's packages to test the changes we wanted to make and validate our ideas. Now, in Keystone Next, we've substantially rewritten the CLI, Schema config, and Admin UI to make them more powerful and easier to use than ever before.

There is a lot more to do, and with a larger than ever team at [Thinkmill](https://www.thinkmill.com.au) working on it, we're excited to show you what we're planning and get it shipped!

We'll be updating this roadmap fortnightly (or as often as we need to) to track progress and plans, find answers or info that matters to your project, and communicate with us more dynamically while we grow the platform.

If youâ€™re looking for active conversations and interactions, please join our [KeystoneJS Slack](https://community.slack.com), and feel free to [open a PR](https://github.com/keystonejs/keystone/pulls).

## Project Status

Keystone Next has been released to npm as a preview of where we're going. Now we're focusing on completing the transition, which includes:

- Updating the core engine and simplifying our architecture
- Separating Keystone 5 and Keystone Next into distinct GitHub projects
- Writing docs and making the new packages easy to get started with

Here's what you'll see in the next month:

- We'll launch [next.keystonejs.com](https://next.keystonejs.com) (this website! you've found it, but we're in stealth)
- A new project starter and getting started guide
- A new set of example projects demoing how to use Keystone Next features
- A Keystone 5 repo created in our GitHub org, which we're going to move the @keystonejs packages into for ongoing maintenance and releases

<SubscribeForm>
  <p>Keep up to date as we progress through our roadmap:</p>
</SubscribeForm>

### ðŸ‘‡ What's next on our list

Weâ€™re status-tagging everything weâ€™re tracking. Leaning on Basecampâ€™s [Shape Up](https://basecamp.com/shapeup/3.4-chapter-12#work-is-like-a-hill) (and RedwoodJS) weâ€™re using colour-coded labels to help surface our activities, making it quicker and clearer for you to understand where things are up to:

- <Status look="notStarted">Not started</Status>
- <Status look="figuringItOut">Figuring it out</Status>
- <Status look="theresAPlan">There's a plan</Status>
- <Status look="makingItHappen">Making it happen</Status>
- <Status look="cleaningUp">Cleaning up</Status>

## Streamlined back-end with Prisma

<Status look="makingItHappen">Making it happen</Status>

[Prisma](https://www.prisma.io/) is the next-generation ORM for JavaScript and TypeScript, and we
added it to Keystone in 2020. It supports PostgreSQL, MySQL and SQLite with MS SQL and MongoDB
support on the way. Today, Prisma is mature enough for Keystone to use and is already more powerful
than the Knex and Mongoose ORMs we used in Keystone 5.

To simplify Keystone's back-end, and let us focus on building higher level features to make content
management and application development on Keystone even better, we're planning to remove our
database adapter infrastructure and translate Keystone APIs to Prisma directly.

Among other benefits, this will (finally!) give us the database schema migration story that Keystone
has always been missing; custom field types will be simpler to add and maintain; and it also means
anyone building apps on Keystone has the full power of Prisma Client available to them.

## Improved Build and Deployment Options

<Status look="makingItHappen">Making it happen</Status>

Deploying a database-backed application to production is still surprisingly complex, and it can be
challenging to find the right tradeoffs and hosting providers. So we're looking at ways Keystone can
help streamline these options.

This will include building for serverless environments, targeting different architectures for your
GraphQL API and Admin UI applications, and independent `dev`, `build` and `start` commands. Thanks
to Prisma, it will also include tools for previewing and managing database changes.

## GraphQL API Updates

<Status look="figuringItOut">Figuring it out</Status>

Keystone's GraphQL API has been stable (no breaking changes!) for several years now. While this has
been great for building front-end apps with confidence, it has held us back from fixing some pain
points (like error handling) for a while now.

We take the stability of code written against Keystone very seriously, and with that in mind are
planning to make some changes to the API that we expect to provide backwards-compatibility and
streamlined migration stories for.

## Field Types Review

<Status look="notStarted">Not started</Status>

We're planning to revisit our field types and make them more powerful and consistent. This will
include new interface options for the Admin UI, new features for validation and logic, and better
`null` value handling.

## Nested (JSON) Fields

<Status look="figuringItOut">Figuring it out</Status>

Often when you're working with items, you want to allow content authors to manage nested repeating
data. Relationships have traditionally been the answer for this, but come with complexity and can't
be ordered.

So we're looking to add support for defining simplified nested schemas to lists, which will be
stored in a JSON field in the database.

## Singletons

<Status look="theresAPlan">There's a plan</Status>

Keystone is great for lists of data, but sometimes you want a single object that is editable through
the Admin UI and accessible in the GraphQL API. So we're planning to add the ability to define
singletons in Keystone's Schema.

## Translation Support

<Status look="notStarted">Not started</Status>

If you're building a website with multi-language support, in Keystone 5 you have to add individual
fields for each translation. To make for a better authoring experience, simpler schema definition,
and streamlined experience for front-end developers we're planning to build first-class support for
translated fields into Keystone.

## Draft / Preview / Publishing Workflow

<Status look="notStarted">Not started</Status>

Previewing content changes is a critical part of editing with confidence, but it's hard to implement
consistently across sets of changes in a relational database backend.

Now that popular front-ends like Next.js have built-in support for live content previews, we're
planning to develop an integrated workflow for Keystone content that will allow authors to preview
sets of content changes in draft, and publish them atomically.

We're also looking at a built-in solution for tracking changes and version history.

## Admin UI Field Groups and Dynamic Updates

<Status look="notStarted">Not started</Status>

When lists get complex, you want to break up the form into multiple sections of fields. Also, some
fields depend on the value of others, and the form should update dynamically as item data is
changed.

We're planning to design a way of defining this behaviour in your List Schema, so you can ship a
better authoring experience out of the box.

## Feedback

We'd love to hear from you! If youâ€™ve got feedback (or praise ðŸ™Œ), send it our way at [@KeystoneJS](https://twitter.com/keystonejs) on Twitter, or start a discussion / ask a question / make some friends in our [KeystoneJS Slack community](https://github.com/keystonejs/keystone/discussions).

export default ({ children }) => <Markdown>{children}</Markdown>;
