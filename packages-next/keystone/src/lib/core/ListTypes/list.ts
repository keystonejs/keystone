import pluralize from 'pluralize';
import type { CacheHint } from 'apollo-cache-control';
import {
  mapKeys,
  omit,
  omitBy,
  unique,
  intersection,
  mergeWhereClause,
  objMerge,
  flatten,
  zipObj,
  createLazyDeferred,
} from '@keystone-next/utils-legacy';
import { parseListAccess } from '@keystone-next/access-control-legacy';
import {
  PrismaAdapter,
  PrismaFieldAdapter,
  PrismaListAdapter,
} from '@keystone-next/adapter-prisma-legacy';
import {
  BaseGeneratedListTypes,
  BaseKeystoneList,
  BaseListConfig,
  GraphQLResolver,
  KeystoneContext,
  ListHooks,
  CacheHintArgs,
} from '@keystone-next/types';
import { Implementation } from '@keystone-next/fields';
import { Relationship } from '@keystone-next/fields/src/types/relationship/Implementation';
import { keyToLabel, labelToPath, labelToClass, opToType, mapToFields } from './utils';
import { HookManager } from './hooks';
import { LimitsExceededError, throwAccessDenied } from './graphqlErrors';

type MutationState = { afterChangeStack: any[]; transaction: {} };

type IdType = string | number;

type CreateUpdateData = Record<string, any>;

type FullFieldConfig = {
  type: {
    type: string;
    implementation: typeof Implementation;
    adapter: typeof PrismaFieldAdapter;
    isRelationship?: boolean;
  };
};

export class List implements BaseKeystoneList {
  key: string;
  _fields: Record<string, FullFieldConfig>;
  _hooks: ListHooks<any>;
  adapter: PrismaListAdapter;
  access: Record<string, any>;
  _schemaNames: string[];
  gqlNames: BaseKeystoneList['gqlNames'];
  fields: Implementation<any>[];
  fieldsByPath: Record<string, Implementation<any>>;
  hookManager: HookManager;
  schemaDoc?: string;
  adminDoc?: string;
  adminUILabels: { label: string; singular: string; plural: string; path: string };
  getListByKey: (key: string) => BaseKeystoneList | undefined;
  fieldsInitialised: boolean;
  queryLimits: { maxResults: number };
  cacheHint?: ((args: CacheHintArgs) => CacheHint) | CacheHint;
  constructor(
    key: string,
    {
      fields,
      hooks = {},
      adminDoc,
      schemaDoc,
      access,
      itemQueryName,
      listQueryName,
      label,
      singular,
      plural,
      path,
      adapterConfig = {},
      queryLimits = {},
      cacheHint,
    }: BaseListConfig,
    {
      getListByKey,
      adapter,
    }: { getListByKey: (key: string) => BaseKeystoneList | undefined; adapter: PrismaAdapter }
  ) {
    this.key = key;
    this._fields = fields;
    this._hooks = hooks;
    this.schemaDoc = schemaDoc;
    this.adminDoc = adminDoc;

    this.getListByKey = getListByKey;

    const _label = label || keyToLabel(key);
    const _singular = singular || pluralize.singular(_label);
    const _plural = plural || pluralize.plural(_label);

    if (_plural === _label) {
      throw new Error(
        `Unable to use ${_label} as a List name - it has an ambiguous plural (${_plural}). Please choose another name for your list.`
      );
    }

    this.adminUILabels = {
      // Fall back to the plural for the label if none was provided, not the autogenerated default from key
      label: label || _plural,
      singular: _singular,
      plural: _plural,
      path: path || labelToPath(_plural),
    };

    const _itemQueryName = itemQueryName || labelToClass(_singular);
    const _listQueryName = listQueryName || labelToClass(_plural);

    this.gqlNames = {
      outputTypeName: this.key,
      itemQueryName: _itemQueryName,
      listQueryName: `all${_listQueryName}`,
      listQueryMetaName: `_all${_listQueryName}Meta`,
      listSortName: `Sort${_listQueryName}By`,
      deleteMutationName: `delete${_itemQueryName}`,
      updateMutationName: `update${_itemQueryName}`,
      createMutationName: `create${_itemQueryName}`,
      deleteManyMutationName: `delete${_listQueryName}`,
      updateManyMutationName: `update${_listQueryName}`,
      createManyMutationName: `create${_listQueryName}`,
      whereInputName: `${_itemQueryName}WhereInput`,
      whereUniqueInputName: `${_itemQueryName}WhereUniqueInput`,
      updateInputName: `${_itemQueryName}UpdateInput`,
      createInputName: `${_itemQueryName}CreateInput`,
      updateManyInputName: `${_listQueryName}UpdateInput`,
      createManyInputName: `${_listQueryName}CreateInput`,
      relateToManyInputName: `${_itemQueryName}RelateToManyInput`,
      relateToOneInputName: `${_itemQueryName}RelateToOneInput`,
    };

    this.adapter = adapter.newListAdapter(this.key, adapterConfig);
    this._schemaNames = ['public'];

    this.access = parseListAccess({
      schemaNames: this._schemaNames,
      listKey: key,
      access,
      defaultAccess: true,
    });

    this.queryLimits = { maxResults: Infinity, ...queryLimits };
    if (this.queryLimits.maxResults < 1) {
      throw new Error(`List ${label}'s queryLimits.maxResults can't be < 1`);
    }

    if (!['object', 'function', 'undefined'].includes(typeof cacheHint)) {
      throw new Error(`List ${label}'s cacheHint must be an object or function`);
    }
    this.cacheHint = cacheHint;

    this.fields = [];
    this.fieldsByPath = {};
    this.hookManager = {} as HookManager;
    this.fieldsInitialised = false;
  }

  initFields() {
    if (this.fieldsInitialised) return;
    this.fieldsInitialised = true;

    let sanitisedFieldsConfig = this._fields;

    // Add an 'id' field if none supplied
    if (!sanitisedFieldsConfig.id) {
      throw new Error(`No 'id' field given for the '${this.key}' list.`);
    }

    // Helpful errors for misconfigured lists
    Object.entries(sanitisedFieldsConfig).forEach(([fieldKey, fieldConfig]) => {
      if (fieldKey[0] === '_') {
        throw new Error(
          `Invalid field name "${fieldKey}". Field names cannot start with an underscore.`
        );
      }
      if (typeof fieldConfig.type === 'undefined') {
        throw new Error(
          `The '${this.key}.${fieldKey}' field doesn't specify a valid type. ` +
            `(${this.key}.${fieldKey}.type is undefined)`
        );
      }
      if (typeof fieldConfig.type.adapter === 'undefined') {
        throw new Error(
          `The type given for the '${this.key}.${fieldKey}' field doesn't define an adapter.`
        );
      }
    });

    this.fieldsByPath = mapKeys(
      sanitisedFieldsConfig,
      ({ type, ...fieldSpec }, path) =>
        new type.implementation(path, fieldSpec, {
          getListByKey: this.getListByKey,
          listKey: this.key,
          listAdapter: this.adapter,
          fieldAdapterClass: type.adapter,
          schemaNames: this._schemaNames,
        })
    );
    this.fields = Object.values(this.fieldsByPath);
    this.hookManager = new HookManager({
      fields: this.fields,
      hooks: this._hooks,
      listKey: this.key,
    });
  }

  getFieldsWithAccess({
    schemaName,
    access,
  }: {
    schemaName: string;
    access: 'read' | 'update' | 'create';
  }) {
    return this.fields
      .filter(({ path }) => path !== 'id') // Exclude the id fields update types
      .filter(field => field.access[schemaName][access]); // If it's globally set to false, makes sense to never let it be updated
  }

  getAllFieldsWithAccess({
    schemaName,
    access,
  }: {
    schemaName: string;
    access: 'create' | 'read' | 'update' | 'create';
  }) {
    // Equivalent to getFieldsWithAccess but includes `id` fields.
    return this.fields.filter(field => field.access[schemaName][access]);
  }

  getGraphqlFilterFragment() {
    return [
      `where: ${this.gqlNames.whereInputName}`,
      `search: String`,
      `sortBy: [${this.gqlNames.listSortName}!]`,
      `orderBy: String`,
      `first: Int`,
      `skip: Int`,
    ];
  }

  _wrapFieldResolver(field: Implementation<any>, innerResolver: GraphQLResolver) {
    // Wrap the "inner" resolver for a single output field with list-specific modifiers
    return (async (item, args, context, info) => {
      // Check access
      const operation = 'read';
      const access = await context.getFieldAccessControlForUser(
        field.access,
        this.key,
        field.path,
        undefined,
        item,
        operation,
        { context }
      );
      if (!access) {
        // If the client handles errors correctly, it should be able to
        // receive partial data (for the fields the user has access to),
        // and then an `errors` array of AccessDeniedError's
        throwAccessDenied(opToType[operation], field.path, { itemId: item ? item.id : null });
      }

      // Only static cache hints are supported at the field level until a use-case makes it clear what parameters a dynamic hint would take
      // @ts-ignore
      if (field.config.cacheHint && info && info.cacheControl) {
        // @ts-ignore
        info.cacheControl.setCacheHint(field.config.cacheHint);
      }

      // Execute the original/inner resolver
      return innerResolver(item, args, context, info);
    }) as GraphQLResolver;
  }

  async checkFieldAccess(
    operation: 'create' | 'read' | 'update' | 'delete',
    itemsToUpdate: {
      existingItem: Record<string, any> | undefined;
      id?: IdType;
      data: Record<string, any>;
    }[],
    context: KeystoneContext,
    { gqlName, ...extraInternalData }: { gqlName: string } & Record<string, any>
  ) {
    const restrictedFields = [];
    for (const { existingItem, id, data } of itemsToUpdate) {
      const fields = this.fields.filter(field => field.path in data);

      for (const field of fields) {
        const access = await context.getFieldAccessControlForUser(
          field.access,
          this.key,
          field.path,
          data,
          existingItem,
          operation,
          { gqlName, itemId: id, context, ...extraInternalData }
        );
        if (!access) {
          restrictedFields.push(field.path);
        }
      }
    }
    if (restrictedFields.length) {
      throwAccessDenied(opToType[operation], gqlName, extraInternalData, { restrictedFields });
    }
  }

  async checkListAccess(
    context: KeystoneContext,
    originalInput: Record<string, any> | undefined,
    operation: 'create' | 'read' | 'update' | 'delete',
    { gqlName, ...extraInternalData }: { gqlName?: string } & Record<string, any>
  ) {
    const access = await context.getListAccessControlForUser(
      this.access,
      this.key,
      originalInput,
      operation,
      { gqlName, context, ...extraInternalData }
    );
    if (!access) {
      // If the client handles errors correctly, it should be able to
      // receive partial data (for the fields the user has access to),
      // and then an `errors` array of AccessDeniedError's
      throwAccessDenied(opToType[operation], gqlName, extraInternalData);
    }
    return access;
  }

  async getAccessControlledItem(
    id: IdType,
    access: any,
    {
      context,
      operation,
      gqlName,
      info,
    }: {
      context: KeystoneContext;
      operation: 'create' | 'read' | 'update' | 'delete';
      gqlName?: string;
      info?: any;
    }
  ) {
    const _throwAccessDenied = () => {
      // If the client handles errors correctly, it should be able to
      // receive partial data (for the fields the user has access to),
      // and then an `errors` array of AccessDeniedError's
      throwAccessDenied(opToType[operation], gqlName, { itemId: id });
    };

    let item;
    if (
      (access.id && access.id !== id) ||
      (access.id_not && access.id_not === id) ||
      (access.id_in && !access.id_in.includes(id)) ||
      (access.id_not_in && access.id_not_in.includes(id))
    ) {
      // It's odd, but conceivable the access control specifies a single id
      // the user has access to. So we have to do a check here to see if the
      // ID they're requesting matches that ID.
      // Nice side-effect: We can throw without having to ever query the DB.
      _throwAccessDenied();
    } else {
      // NOTE: The fields will be filtered by the ACL checking in gqlFieldResolvers()
      // We only want 1 item, don't make the DB do extra work
      // NOTE: Order in where: { ... } doesn't matter, if `access.id !== id`, it will
      // have been caught earlier, so this spread and overwrite can only
      // ever be additive or overwrite with the same value
      item = (
        (await this._itemsQuery(
          { first: 1, where: { ...access, id } },
          { context, info }
        )) as Record<string, any>[]
      )[0];
    }
    if (!item) {
      // Throwing an AccessDenied here if the item isn't found because we're
      // strict about accidentally leaking information (that the item doesn't
      // exist)
      // NOTE: There is a potential security risk here if we were to
      // further check the existence of an item with the given ID: It'd be
      // possible to figure out if records with particular IDs exist in
      // the DB even if the user doesn't have access (eg; check a bunch of
      // IDs, and the ones that return AccessDenied exist, and the ones
      // that return null do not exist). Similar to how S3 returns 403's
      // always instead of ever returning 404's.
      // Our version is to always throw if not found.
      _throwAccessDenied();
    }
    // Found the item, and it passed the filter test
    return item as { id: IdType } & Record<string, any>;
  }

  async getAccessControlledItems(
    ids: IdType[],
    access: any,
    { context, info }: { context?: KeystoneContext; info?: any } = {}
  ) {
    if (ids.length === 0) {
      return [];
    }

    const uniqueIds = unique(ids);

    // Early out - the user has full access to operate on this list
    if (access === true) {
      return await this._itemsQuery({ where: { id_in: uniqueIds } }, { context, info });
    }

    let idFilters: Record<string, any> = {};

    if (access.id || access.id_in) {
      const accessControlIdsAllowed = unique([].concat(access.id, access.id_in).filter(id => id));

      idFilters.id_in = intersection(accessControlIdsAllowed, uniqueIds);
    } else {
      idFilters.id_in = uniqueIds;
    }

    if (access.id_not || access.id_not_in) {
      const accessControlIdsDisallowed = unique(
        [].concat(access.id_not, access.id_not_in).filter(id => id)
      );

      idFilters.id_not_in = intersection(accessControlIdsDisallowed, uniqueIds);
    }

    // It's odd, but conceivable the access control specifies a single id
    // the user has access to. So we have to do a check here to see if the
    // ID they're requesting matches that ID.
    // Nice side-effect: We can throw without having to ever query the DB.
    if (
      // Only some ids are allowed, and none of them have been passed in
      (idFilters.id_in && idFilters.id_in.length === 0) ||
      // All the passed in ids have been explicitly disallowed
      (idFilters.id_not_in && idFilters.id_not_in.length === uniqueIds.length)
    ) {
      // NOTE: We don't throw an error for multi-actions, only return an empty
      // array because there's no mechanism in GraphQL to return more than one
      // error for a list result.
      return [];
    }

    // NOTE: The fields will be filtered by the ACL checking in gqlFieldResolvers()
    // NOTE: Unlike in the single-operation variation, there is no security risk
    // in returning the result of the query here, because if no items match, we
    // return an empty array regardless of if that's because of lack of
    // permissions or because of those items don't exist.
    const remainingAccess = omit(access, ['id', 'id_not', 'id_in', 'id_not_in']);
    return await this._itemsQuery(
      { where: { ...remainingAccess, ...idFilters } },
      { context, info }
    );
  }

  async listQuery(
    args: BaseGeneratedListTypes['args']['listQuery'],
    context: KeystoneContext,
    gqlName: string,
    info: any,
    from?: any
  ) {
    const access = await this.checkListAccess(context, undefined, 'read', { gqlName });

    return this._itemsQuery(mergeWhereClause(args, access), { context, info, from }) as Promise<
      Record<string, any>[]
    >;
  }

  async listQueryMeta(
    args: Record<string, any>,
    context: KeystoneContext,
    gqlName: string,
    info: any,
    from?: any
  ) {
    return {
      // Return these as functions so they're lazily evaluated depending
      // on what the user requested
      // Evaluation takes place in ../Keystone/index.js
      getCount: async () => {
        const access = await this.checkListAccess(context, undefined, 'read', { gqlName });

        const { count } = (await this._itemsQuery(mergeWhereClause(args, access), {
          meta: true,
          context,
          info,
          from,
        })) as { count: number };

        return count;
      },
    };
  }

  async itemQuery(
    { where: { id } }: { where: { id: string } },
    context: KeystoneContext,
    gqlName?: string,
    info?: any
  ) {
    const operation = 'read';

    const access = await this.checkListAccess(context, undefined, operation, {
      gqlName,
      itemId: id,
    });

    return this.getAccessControlledItem(id, access, { context, operation, gqlName, info });
  }

  async _itemsQuery(
    args: Record<string, any>,
    {
      meta,
      context,
      info,
      from,
    }: { meta?: boolean; context?: KeystoneContext; info?: any; from?: {} } = {}
  ) {
    // This is private because it doesn't handle access control

    const { maxResults } = this.queryLimits;

    const throwLimitsExceeded = (args: { type: string; limit: number }) => {
      throw new LimitsExceededError({ data: { list: this.key, ...args } });
    };

    // Need to enforce List-specific query limits
    const { first = Infinity } = args;
    // We want to help devs by failing fast and noisily if limits are violated.
    // Unfortunately, we can't always be sure of intent.
    // E.g., if the query has a "first: 10", is it bad if more results could come back?
    // Maybe yes, or maybe the dev is just paginating posts.
    // But we can be sure there's a problem in two cases:
    // * The query explicitly has a "first" that exceeds the limit
    // * The query has no "first", and has more results than the limit
    if (first < Infinity && first > maxResults) {
      throwLimitsExceeded({ type: 'maxResults', limit: maxResults });
    }
    if (!meta) {
      // "first" is designed to truncate the count value, but accurate counts are still
      // needed for pagination.  resultsLimit is meant for protecting KS memory usage,
      // not DB performance, anyway, so resultsLimit is only applied to queries that
      // could return many results.
      // + 1 to allow limit violation detection
      const resultsLimit = Math.min(maxResults + 1, first);
      if (resultsLimit < Infinity) {
        args.first = resultsLimit;
      }
    }
    const results = await this.adapter.itemsQuery(args, { meta, from });
    if (Array.isArray(results) && results.length > maxResults) {
      throwLimitsExceeded({ type: 'maxResults', limit: maxResults });
    }
    if (context) {
      context.totalResults += Array.isArray(results) ? results.length : 1;
      if (context.totalResults > context.maxTotalResults) {
        throwLimitsExceeded({ type: 'maxTotalResults', limit: context.maxTotalResults });
      }
    }

    if (info && info.cacheControl) {
      switch (typeof this.cacheHint) {
        case 'object':
          info.cacheControl.setCacheHint(this.cacheHint);
          break;

        case 'function':
          const operationName = info.operation.name && info.operation.name.value;
          info.cacheControl.setCacheHint(this.cacheHint({ results, operationName, meta: !!meta }));
          break;

        case 'undefined':
          break;
      }
    }

    return results;
  }

  // Mutation resolvers
  _fieldsFromObject(obj: Record<string, any>) {
    return Object.keys(obj)
      .map(fieldPath => this.fieldsByPath[fieldPath])
      .filter(field => field);
  }

  async _resolveRelationship(
    data: Record<string, any>,
    existingItem: Record<string, any> | undefined,
    context: KeystoneContext,
    getItem: any,
    mutationState: MutationState
  ) {
    const fields = this._fieldsFromObject(data).filter(
      field => field.isRelationship
    ) as Relationship<any>[];
    const resolvedRelationships = await mapToFields(fields, async field => {
      // Treat `null` as `undefined`, e.g. a no-op
      if (data[field.path] === null) return undefined;
      const { create, connect, disconnect, currentValue } = await field.resolveNestedOperations(
        data[field.path],
        existingItem,
        context,
        mutationState
      );
      // This code codifies the order of operations for nested mutations:
      // 1. disconnectAll
      // 2. disconnect
      // 3. create
      // 4. connect
      if (field.many) {
        return [
          ...(currentValue as string[]).filter((id: string) => !disconnect.includes(id)),
          ...connect,
          ...create,
        ].filter(id => !!id);
      } else {
        return create && create[0]
          ? create[0]
          : connect && connect[0]
          ? connect[0]
          : disconnect && disconnect[0]
          ? null
          : currentValue;
      }
    });

    return { ...data, ...resolvedRelationships };
  }

  async _resolveDefaults({
    context,
    originalInput,
  }: {
    context: KeystoneContext;
    originalInput: Record<string, any>;
  }) {
    const args = { context, originalInput };

    const fieldsWithoutValues = this.fields.filter(
      field => typeof originalInput[field.path] === 'undefined'
    );

    const defaultValues = await mapToFields(fieldsWithoutValues, field =>
      field.getDefaultValue(args)
    );

    return {
      ...omitBy(defaultValues, path => typeof defaultValues[path] === 'undefined'),
      ...originalInput,
    };
  }

  async _nestedMutation(
    mutationState: MutationState | undefined,
    mutation: (mutationState: MutationState) => Promise<{ result: any; afterHook: any }>
  ) {
    // Set up a fresh mutation state if we're the root mutation
    const isRootMutation = !mutationState;
    if (!mutationState) {
      mutationState = {
        afterChangeStack: [], // post-hook stack
        transaction: {}, // transaction
      };
    }

    // Perform the mutation
    const { result, afterHook } = await mutation(mutationState);

    // Push after-hook onto the stack and resolve all if we're the root.
    const { afterChangeStack } = mutationState;
    afterChangeStack.push(afterHook);
    if (isRootMutation) {
      // TODO: Close transaction

      // Execute post-hook stack
      while (afterChangeStack.length) {
        await afterChangeStack.pop()();
      }
    }

    // Return the result of the mutation
    return result;
  }

  async createMutation(
    data: CreateUpdateData,
    context: KeystoneContext,
    mutationState?: MutationState
  ) {
    const operation = 'create';
    const gqlName = this.gqlNames.createMutationName;

    await this.checkListAccess(context, data, operation, { gqlName });

    const existingItem = undefined;

    const itemsToUpdate = [{ existingItem, data }];

    await this.checkFieldAccess(operation, itemsToUpdate, context, { gqlName });

    return await this._createSingle(data, context, mutationState);
  }

  async createManyMutation(
    data: { data: CreateUpdateData }[],
    context: KeystoneContext,
    mutationState?: MutationState
  ) {
    const operation = 'create';
    const gqlName = this.gqlNames.createManyMutationName;

    await this.checkListAccess(context, data, operation, { gqlName });

    const itemsToUpdate = data.map(d => ({ existingItem: undefined, data: d.data }));

    await this.checkFieldAccess(operation, itemsToUpdate, context, { gqlName });

    return Promise.all(data.map(d => this._createSingle(d.data, context, mutationState)));
  }

  async _createSingle(
    originalInput: Record<string, any>,
    context: KeystoneContext,
    mutationState?: MutationState
  ) {
    const operation = 'create';
    const existingItem = undefined;
    return await this._nestedMutation(mutationState, async (mutationState: MutationState) => {
      const defaultedItem = await this._resolveDefaults({ context, originalInput });

      // Enable resolveRelationship to perform some action after the item is created by
      // giving them a promise which will eventually resolve with the value of the
      // newly created item.
      const createdPromise = createLazyDeferred();

      let resolvedData = await this._resolveRelationship(
        defaultedItem,
        existingItem,
        context,
        createdPromise.promise,
        mutationState
      );

      resolvedData = await this.hookManager.resolveInput({
        resolvedData,
        existingItem,
        context,
        operation,
        originalInput,
      });

      await this.hookManager.validateInput({
        resolvedData,
        existingItem,
        context,
        operation,
        originalInput,
      });

      await this.hookManager.beforeChange({
        resolvedData,
        existingItem,
        context,
        operation,
        originalInput,
      });

      let updatedItem: Record<string, any>;
      try {
        updatedItem = (await this.adapter.create(resolvedData)) as Record<string, any>;
        createdPromise.resolve(updatedItem);
        // Wait until next tick so the promise/micro-task queue can be flushed
        // fully, ensuring the deferred handlers get executed before we move on
        await new Promise(res => process.nextTick(res));
      } catch (error) {
        createdPromise.reject(error);
        // Wait until next tick so the promise/micro-task queue can be flushed
        // fully, ensuring the deferred handlers get executed before we move on
        await new Promise(res => process.nextTick(res));
        // Rethrow the error to ensure it's surfaced to Apollo
        throw error;
      }

      return {
        result: updatedItem,
        afterHook: () =>
          this.hookManager.afterChange({
            updatedItem,
            existingItem,
            context,
            operation,
            originalInput,
          }),
      };
    });
  }

  async updateMutation(
    id: IdType,
    data: CreateUpdateData,
    context: KeystoneContext,
    mutationState?: MutationState
  ) {
    const operation = 'update';
    const gqlName = this.gqlNames.updateMutationName;
    const extraData = { gqlName, itemId: id };

    const access = await this.checkListAccess(context, data, operation, extraData);

    const existingItem = await this.getAccessControlledItem(id, access, {
      context,
      operation,
      gqlName,
    });

    const itemsToUpdate = [{ existingItem, data }];

    await this.checkFieldAccess(operation, itemsToUpdate, context, extraData);

    return await this._updateSingle(id, data, existingItem, context, mutationState);
  }

  async updateManyMutation(
    data: { id: IdType; data: CreateUpdateData }[],
    context: KeystoneContext,
    mutationState?: MutationState
  ) {
    const operation = 'update';
    const gqlName = this.gqlNames.updateManyMutationName;
    const ids = data.map(d => d.id);
    const extraData = { gqlName, itemIds: ids };

    const access = await this.checkListAccess(context, data, operation, extraData);
    const existingItems = (await this.getAccessControlledItems(ids, access)) as Record<
      string,
      any
    >[];

    // Only update those items which pass access control
    const itemsToUpdate = zipObj({
      existingItem: existingItems,
      id: existingItems.map(({ id }) => id), // itemId is taken from here in checkFieldAccess
      data: existingItems.map(({ id }) => data.find(d => d.id === id)!.data),
    }) as { existingItem: Record<string, any>; id: IdType; data: Record<string, any> }[];

    // FIXME: We should do all of these in parallel and return *all* the field access violations
    await this.checkFieldAccess(operation, itemsToUpdate, context, extraData);

    if (this.adapter.parentAdapter.provider === 'sqlite') {
      // We perform these operations sequentially as a workaround for a connection
      // timeout bug that happens in prisma+sqlite: https://github.com/prisma/prisma/issues/2955
      const ret = [];
      for (const item of itemsToUpdate) {
        const { existingItem, id, data } = item;
        ret.push(await this._updateSingle(id, data, existingItem, context, mutationState));
      }
      return ret;
    } else {
      return Promise.all(
        itemsToUpdate.map(({ existingItem, id, data }) =>
          this._updateSingle(id, data, existingItem, context, mutationState)
        )
      );
    }
  }

  async _updateSingle(
    id: IdType,
    originalInput: Record<string, any>,
    existingItem: Record<string, any>,
    context: KeystoneContext,
    mutationState?: MutationState
  ) {
    const operation = 'update';
    return await this._nestedMutation(mutationState, async (mutationState: MutationState) => {
      let resolvedData = await this._resolveRelationship(
        originalInput,
        existingItem,
        context,
        undefined,
        mutationState
      );

      resolvedData = await this.hookManager.resolveInput({
        resolvedData,
        existingItem,
        context,
        operation,
        originalInput,
      });

      await this.hookManager.validateInput({
        resolvedData,
        existingItem,
        context,
        operation,
        originalInput,
      });

      await this.hookManager.beforeChange({
        resolvedData,
        existingItem,
        context,
        operation,
        originalInput,
      });

      const updatedItem = (await this.adapter.update(id, resolvedData)) as Record<string, any>;

      return {
        result: updatedItem,
        afterHook: () =>
          this.hookManager.afterChange({
            updatedItem,
            existingItem,
            context,
            operation,
            originalInput,
          }),
      };
    });
  }

  async deleteMutation(id: IdType, context: KeystoneContext, mutationState?: MutationState) {
    const operation = 'delete';
    const gqlName = this.gqlNames.deleteMutationName;

    const access = await this.checkListAccess(context, undefined, operation, {
      gqlName,
      itemId: id,
    });

    const existingItem = await this.getAccessControlledItem(id, access, {
      context,
      operation,
      gqlName,
    });

    return this._deleteSingle(existingItem, context, mutationState);
  }

  async deleteManyMutation(ids: IdType[], context: KeystoneContext, mutationState?: MutationState) {
    const operation = 'delete';
    const gqlName = this.gqlNames.deleteManyMutationName;

    const access = await this.checkListAccess(context, undefined, operation, {
      gqlName,
      itemIds: ids,
    });

    const existingItems = (await this.getAccessControlledItems(ids, access)) as any[];

    if (this.adapter.parentAdapter.provider === 'sqlite') {
      // We perform these operations sequentially as a workaround for a connection
      // timeout bug that happens in prisma+sqlite: https://github.com/prisma/prisma/issues/2955
      const ret = [];
      for (const existingItem of existingItems) {
        ret.push(await this._deleteSingle(existingItem, context, mutationState));
      }
      return ret;
    } else {
      return Promise.all(
        existingItems.map(existingItem => this._deleteSingle(existingItem, context, mutationState))
      );
    }
  }

  async _deleteSingle(
    existingItem: { id: IdType } & Record<string, any>,
    context: KeystoneContext,
    mutationState?: MutationState
  ) {
    const operation = 'delete';

    return await this._nestedMutation(mutationState, async () => {
      await this.hookManager.validateDelete({ existingItem, context, operation });

      await this.hookManager.beforeDelete({ existingItem, context, operation });

      await this.adapter.delete(existingItem.id);

      return {
        result: existingItem,
        afterHook: () => this.hookManager.afterDelete({ existingItem, context, operation }),
      };
    });
  }

  // Methods called from ListCRUDProvider
  getGqlTypes({ schemaName }: { schemaName: string }) {
    const schemaAccess = this.access[schemaName];
    const types = [];

    // We want to include `id` fields
    // If read is globally set to false, makes sense to never show it
    const readFields = this.getAllFieldsWithAccess({ schemaName, access: 'read' });
    if (schemaAccess.read || schemaAccess.create || schemaAccess.update || schemaAccess.delete) {
      types.push(
        ...flatten(this.fields.map(field => field.getGqlAuxTypes({ schemaName }))),
        `
        """ ${this.schemaDoc || 'A keystone list'} """
        type ${this.gqlNames.outputTypeName} {
          ${flatten(
            readFields.map(field =>
              field.schemaDoc
                ? `""" ${field.schemaDoc} """ ${field.gqlOutputFields({ schemaName })}`
                : field.gqlOutputFields({ schemaName })
            )
          ).join('\n')}
        }`,

        // https://github.com/opencrud/opencrud/blob/master/spec/2-relational/2-2-queries/2-2-3-filters.md#boolean-expressions
        `
        input ${this.gqlNames.whereInputName} {
          AND: [${this.gqlNames.whereInputName}]
          OR: [${this.gqlNames.whereInputName}]

          ${flatten(readFields.map(field => field.gqlQueryInputFields({ schemaName }))).join('\n')}
        }`,
        // TODO: Include other `unique` fields and allow filtering by them
        `
        input ${this.gqlNames.whereUniqueInputName} {
          id: ID!
        }`
      );

      const sortOptions = flatten(
        readFields.map(({ path, isOrderable }) =>
          // Explicitly allow sorting by id
          isOrderable || path === 'id' ? [`${path}_ASC`, `${path}_DESC`] : []
        )
      );

      if (sortOptions.length) {
        types.push(`
          enum ${this.gqlNames.listSortName} {
            ${sortOptions.join('\n')}
          }
        `);
      }
    }

    const updateFields = this.getFieldsWithAccess({ schemaName, access: 'update' });
    if (schemaAccess.update && updateFields.length) {
      types.push(`
        input ${this.gqlNames.updateInputName} {
          ${flatten(updateFields.map(field => field.gqlUpdateInputFields({ schemaName }))).join(
            '\n'
          )}
        }
      `);
      types.push(`
        input ${this.gqlNames.updateManyInputName} {
          id: ID!
          data: ${this.gqlNames.updateInputName}
        }
      `);
    }

    const createFields = this.getFieldsWithAccess({ schemaName, access: 'create' });
    if (schemaAccess.create && createFields.length) {
      types.push(`
        input ${this.gqlNames.createInputName} {
          ${flatten(createFields.map(field => field.gqlCreateInputFields({ schemaName }))).join(
            '\n'
          )}
        }
      `);
      types.push(`
        input ${this.gqlNames.createManyInputName} {
          data: ${this.gqlNames.createInputName}
        }
      `);
    }

    return types;
  }

  getGqlQueries({ schemaName }: { schemaName: string }): string[] {
    const schemaAccess = this.access[schemaName];
    // All the auxiliary queries the fields want to add
    const queries = flatten(this.fields.map(field => field.getGqlAuxQueries()));

    // If `read` is either `true`, or a function (we don't care what the result
    // of the function is, that'll get executed at a later time)
    if (schemaAccess.read) {
      queries.push(
        `
        """ Search for all ${this.gqlNames.outputTypeName} items which match the where clause. """
        ${this.gqlNames.listQueryName}(
          ${this.getGraphqlFilterFragment().join('\n')}
        ): [${this.gqlNames.outputTypeName}]`,

        `
        """ Search for the ${this.gqlNames.outputTypeName} item with the matching ID. """
        ${this.gqlNames.itemQueryName}(
          where: ${this.gqlNames.whereUniqueInputName}!
        ): ${this.gqlNames.outputTypeName}`,

        `
        """ Perform a meta-query on all ${
          this.gqlNames.outputTypeName
        } items which match the where clause. """
        ${this.gqlNames.listQueryMetaName}(
          ${this.getGraphqlFilterFragment().join('\n')}
        ): _QueryMeta`
      );
    }

    return queries;
  }

  getGqlMutations({ schemaName }: { schemaName: string }) {
    const schemaAccess = this.access[schemaName];
    const mutations = [];

    // NOTE: We only check for truthy as it could be `true`, or a function (the
    // function is executed later in the resolver)

    const createFields = this.getFieldsWithAccess({ schemaName, access: 'create' });
    if (schemaAccess.create && createFields.length) {
      mutations.push(`
        """ Create a single ${this.gqlNames.outputTypeName} item. """
        ${this.gqlNames.createMutationName}(
          data: ${this.gqlNames.createInputName}
        ): ${this.gqlNames.outputTypeName}
      `);

      mutations.push(`
        """ Create multiple ${this.gqlNames.outputTypeName} items. """
        ${this.gqlNames.createManyMutationName}(
          data: [${this.gqlNames.createManyInputName}]
        ): [${this.gqlNames.outputTypeName}]
      `);
    }

    const updateFields = this.getFieldsWithAccess({ schemaName, access: 'update' });
    if (schemaAccess.update && updateFields.length) {
      mutations.push(`
      """ Update a single ${this.gqlNames.outputTypeName} item by ID. """
        ${this.gqlNames.updateMutationName}(
          id: ID!
          data: ${this.gqlNames.updateInputName}
        ): ${this.gqlNames.outputTypeName}
      `);

      mutations.push(`
      """ Update multiple ${this.gqlNames.outputTypeName} items by ID. """
        ${this.gqlNames.updateManyMutationName}(
          data: [${this.gqlNames.updateManyInputName}]
        ): [${this.gqlNames.outputTypeName}]
      `);
    }

    if (schemaAccess.delete) {
      mutations.push(`
        """ Delete a single ${this.gqlNames.outputTypeName} item by ID. """
        ${this.gqlNames.deleteMutationName}(
          id: ID!
        ): ${this.gqlNames.outputTypeName}
      `);

      mutations.push(`
        """ Delete multiple ${this.gqlNames.outputTypeName} items by ID. """
        ${this.gqlNames.deleteManyMutationName}(
          ids: [ID!]
        ): [${this.gqlNames.outputTypeName}]
      `);
    }

    return mutations;
  }

  gqlAuxFieldResolvers({ schemaName }: { schemaName: string }): Record<string, any> {
    const schemaAccess = this.access[schemaName];
    if (schemaAccess.read || schemaAccess.create || schemaAccess.update || schemaAccess.delete) {
      return objMerge(this.fields.map(field => field.gqlAuxFieldResolvers({ schemaName })));
    }
    return {};
  }

  gqlFieldResolvers({ schemaName }: { schemaName: string }): Record<string, any> {
    const schemaAccess = this.access[schemaName];
    if (!schemaAccess.read) {
      return {};
    }

    return {
      [this.gqlNames.outputTypeName]: objMerge(
        this.fields
          .filter(field => field.access[schemaName].read)
          .map(field =>
            // Get the resolvers for the (possibly multiple) output fields and wrap each with list-specific modifiers
            mapKeys(field.gqlOutputFieldResolvers({ schemaName }), innerResolver =>
              this._wrapFieldResolver(field, innerResolver)
            )
          )
      ),
    };
  }

  gqlAuxQueryResolvers(): Record<string, any> {
    // TODO: Obey the same ACL rules based on parent type
    return objMerge(this.fields.map(field => field.gqlAuxQueryResolvers()));
  }

  gqlQueryResolvers({ schemaName }: { schemaName: string }) {
    const schemaAccess = this.access[schemaName];
    let resolvers: Record<string, GraphQLResolver> = {};

    // If set to false, we can confidently remove these resolvers entirely from
    // the graphql schema
    if (schemaAccess.read) {
      resolvers = {
        [this.gqlNames.listQueryName]: (_, args, context, info) =>
          this.listQuery(args, context, this.gqlNames.listQueryName, info),

        [this.gqlNames.listQueryMetaName]: (_, args, context, info) =>
          this.listQueryMeta(args, context, this.gqlNames.listQueryMetaName, info),

        [this.gqlNames.itemQueryName]: (_, args, context, info) =>
          this.itemQuery(args, context, this.gqlNames.itemQueryName, info),
      };
    }

    return resolvers;
  }

  gqlMutationResolvers({ schemaName }: { schemaName: string }) {
    const schemaAccess = this.access[schemaName];
    const mutationResolvers: Record<string, GraphQLResolver> = {};

    const createFields = this.getFieldsWithAccess({ schemaName, access: 'create' });
    if (schemaAccess.create && createFields.length) {
      mutationResolvers[this.gqlNames.createMutationName] = (_, { data }, context) =>
        this.createMutation(data, context);

      mutationResolvers[this.gqlNames.createManyMutationName] = (_, { data }, context) =>
        this.createManyMutation(data, context);
    }

    const updateFields = this.getFieldsWithAccess({ schemaName, access: 'update' });
    if (schemaAccess.update && updateFields.length) {
      mutationResolvers[this.gqlNames.updateMutationName] = (_, { id, data }, context) =>
        this.updateMutation(id, data, context);

      mutationResolvers[this.gqlNames.updateManyMutationName] = (_, { data }, context) =>
        this.updateManyMutation(data, context);
    }

    if (schemaAccess.delete) {
      mutationResolvers[this.gqlNames.deleteMutationName] = (_, { id }, context) =>
        this.deleteMutation(id, context);

      mutationResolvers[this.gqlNames.deleteManyMutationName] = (_, { ids }, context) =>
        this.deleteManyMutation(ids, context);
    }

    return mutationResolvers;
  }
}
