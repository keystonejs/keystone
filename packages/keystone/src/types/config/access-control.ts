import type { MaybePromise } from '../utils';
import type { BaseGeneratedListTypes, KeystoneContext } from '..';

type BaseAccessArgs = {
  session: any;
  listKey: string;
  context: KeystoneContext;
};

// List Filter Access

type FilterOutput<GeneratedListTypes extends BaseGeneratedListTypes> =
  | boolean
  | GeneratedListTypes['inputs']['where'];

export type ListFilterAccessControl<
  Operation extends 'create' | 'query' | 'update' | 'delete',
  GeneratedListTypes extends BaseGeneratedListTypes
> =
  | FilterOutput<GeneratedListTypes>
  | ((
      args: BaseAccessArgs & { operation: Operation }
    ) => MaybePromise<FilterOutput<GeneratedListTypes>>);

// List Item Access

type CreateItemAccessArgs<GeneratedListTypes extends BaseGeneratedListTypes> = BaseAccessArgs & {
  operation: 'create';
  /**
   * The input passed in from the GraphQL API
   */
  originalInput: GeneratedListTypes['inputs']['create'];
};

export type CreateListItemAccessControl<GeneratedListTypes extends BaseGeneratedListTypes> = (
  args: CreateItemAccessArgs<GeneratedListTypes>
) => MaybePromise<boolean>;

type UpdateItemAccessArgs<GeneratedListTypes extends BaseGeneratedListTypes> = BaseAccessArgs & {
  operation: 'update';
  /**
   * The item being updated
   */
  item: GeneratedListTypes['backing'];
  /**
   * The input passed in from the GraphQL API
   */
  originalInput: GeneratedListTypes['inputs']['update'];
};

export type UpdateListItemAccessControl<GeneratedListTypes extends BaseGeneratedListTypes> = (
  args: UpdateItemAccessArgs<GeneratedListTypes>
) => MaybePromise<boolean>;

type DeleteItemAccessArgs<GeneratedListTypes extends BaseGeneratedListTypes> = BaseAccessArgs & {
  operation: 'delete';
  /**
   * The item being deleted
   */
  item: GeneratedListTypes['backing'];
};

export type DeleteListItemAccessControl<GeneratedListTypes extends BaseGeneratedListTypes> = (
  args: DeleteItemAccessArgs<GeneratedListTypes>
) => MaybePromise<boolean>;

export type ListOperationAccessControl<Operation extends 'create' | 'query' | 'update' | 'delete'> =
  (args: BaseAccessArgs & { operation: Operation }) => MaybePromise<boolean>;

// List level access control lets you set permissions on the autogenerated CRUD API for each list.
//
// * `operation` access lets you check the information in the `context` and `session` objects to decide if the
// user is allow to access the list.
// * `filter` access lets you provide a GraphQL filter which defines the items the user is allowed to access.
// * `item` access lets you write a function which inspects the provided input data and the existing object (if it exists)
// and make a decision based on this extra data.
//
// If access is denied due to any of the access control methods then the following response will be returned from the GraphQL API:
//   Mutations:
//     - Single operations will return `null` and return an access denied error
//     - Multi operations will return a data array with `null` values for the items which have access denied.
//       Access denied errors will be return for each `null` items.
//   Queries:
//     - Single item queries will return `null` with no errors.
//     - Many item queries will filter out those items which have access denied, with no errors.
//     - Count queries will only count those items for which access is not denied, with no errors.
//
export type ListAccessControl<GeneratedListTypes extends BaseGeneratedListTypes> = {
  // These functions should return `true` if access is allowed or `false` if access is denied.
  operation?: {
    query?: ListOperationAccessControl<'query'>;
    create?: ListOperationAccessControl<'create'>;
    update?: ListOperationAccessControl<'update'>;
    delete?: ListOperationAccessControl<'delete'>;
  };

  // The 'filter' rules can return either:
  // - a filter. In this case, the operation can proceed, but the filter will be additionally applied when updating/reading/deleting
  //   which may make it appear that some of the items don't exist.
  // - boolean true/false. If false, treated as a filter that never matches.
  filter?: {
    query?: ListFilterAccessControl<'query', GeneratedListTypes>;
    update?: ListFilterAccessControl<'update', GeneratedListTypes>;
    delete?: ListFilterAccessControl<'delete', GeneratedListTypes>;
    // create: not supported: FIXME: Add explicit check that people don't try this.
    // FIXME: Write tests for parseAccessControl.
  };

  // These rules are applied to each item being operated on individually. They return `true` or `false`,
  // and if false, an access denied error will be returned for the individual operation.
  item?: {
    // query: not supported
    create?: CreateListItemAccessControl<GeneratedListTypes>;
    update?: UpdateListItemAccessControl<GeneratedListTypes>;
    delete?: DeleteListItemAccessControl<GeneratedListTypes>;
  };
};

// Field Access
export type IndividualFieldAccessControl<Args> = (args: Args) => MaybePromise<boolean>;

export type FieldCreateItemAccessArgs<GeneratedListTypes extends BaseGeneratedListTypes> =
  CreateItemAccessArgs<GeneratedListTypes> & { fieldKey: string };

export type FieldReadItemAccessArgs<GeneratedListTypes extends BaseGeneratedListTypes> =
  BaseAccessArgs & { fieldKey: string; item: GeneratedListTypes['backing'] };

export type FieldUpdateItemAccessArgs<GeneratedListTypes extends BaseGeneratedListTypes> =
  UpdateItemAccessArgs<GeneratedListTypes> & { fieldKey: string };

export type FieldAccessControl<GeneratedListTypes extends BaseGeneratedListTypes> =
  | {
      read?: IndividualFieldAccessControl<FieldReadItemAccessArgs<GeneratedListTypes>>;
      create?: IndividualFieldAccessControl<FieldCreateItemAccessArgs<GeneratedListTypes>>;
      update?: IndividualFieldAccessControl<FieldUpdateItemAccessArgs<GeneratedListTypes>>;
      // filter?: COMING SOON
      // orderBy?: COMING SOON
    }
  | IndividualFieldAccessControl<
      | FieldCreateItemAccessArgs<GeneratedListTypes>
      | FieldReadItemAccessArgs<GeneratedListTypes>
      | FieldUpdateItemAccessArgs<GeneratedListTypes>
    >;
