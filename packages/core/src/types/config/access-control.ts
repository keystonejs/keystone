import type { MaybePromise } from '../utils';
import type { KeystoneContextFromModelTypeInfo } from '..';
import { BaseListTypeInfo, BaseModelTypeInfo } from '../type-info';

type BaseAccessArgs<ModelTypeInfo extends BaseModelTypeInfo> = {
  session: any;
  modelKey: string;
  context: KeystoneContextFromModelTypeInfo<ModelTypeInfo>;
};

type FilterOutput<ModelTypeInfo extends BaseModelTypeInfo> =
  | boolean
  | ModelTypeInfo['inputs']['where'];

export type FilterAccessControl<
  Operation extends 'query' | 'update' | 'delete',
  ModelTypeInfo extends BaseModelTypeInfo
> = (
  args: BaseAccessArgs<ModelTypeInfo> & { operation: Operation }
) => MaybePromise<FilterOutput<ModelTypeInfo>>;

type CreateItemAccessArgs<ModelTypeInfo extends BaseModelTypeInfo> =
  BaseAccessArgs<ModelTypeInfo> & {
    operation: 'create';
    /**
     * The input passed in from the GraphQL API
     */
    inputData: ModelTypeInfo['inputs']['create'];
  };

export type CreateItemAccessControl<ListTypeInfo extends BaseListTypeInfo> = (
  args: CreateItemAccessArgs<ListTypeInfo>
) => MaybePromise<boolean>;

type UpdateItemAccessArgs<ModelTypeInfo extends BaseModelTypeInfo> =
  BaseAccessArgs<ModelTypeInfo> & {
    operation: 'update';
    /**
     * The item being updated
     */
    item: ModelTypeInfo['item'];
    /**
     * The input passed in from the GraphQL API
     */
    inputData: ModelTypeInfo['inputs']['update'];
  };

export type UpdateItemAccessControl<ModelTypeInfo extends BaseModelTypeInfo> = (
  args: UpdateItemAccessArgs<ModelTypeInfo>
) => MaybePromise<boolean>;

type DeleteItemAccessArgs<ModelTypeInfo extends BaseModelTypeInfo> =
  BaseAccessArgs<ModelTypeInfo> & {
    operation: 'delete';
    /**
     * The item being deleted
     */
    item: ModelTypeInfo['item'];
  };

export type DeleteItemAccessControl<ModelTypeInfo extends BaseModelTypeInfo> = (
  args: DeleteItemAccessArgs<ModelTypeInfo>
) => MaybePromise<boolean>;

export type OperationAccessControl<
  Operation extends 'create' | 'query' | 'update' | 'delete',
  ModelTypeInfo extends BaseModelTypeInfo
> = (args: BaseAccessArgs<ModelTypeInfo> & { operation: Operation }) => MaybePromise<boolean>;

// Model level access control lets you set permissions on the autogenerated CRUD API for each model.
//
// * `operation` access lets you check the information in the `context` and `session` objects to decide if the
// user is allow to access the model.
// * `filter` access lets you provide a GraphQL filter which defines the items the user is allowed to access.
// * `item` access lets you write a function which inspects the provided input data and the existing object (if it exists)
// and make a decision based on this extra data.
//
// If access is denied due to any of the access control methods then the following response will be returned from the GraphQL API:
//   Mutations:
//     - Single operations will return `null` and return an access denied error
//     - Multi operations will return a data array with `null` values for the items which have access denied.
//       Access denied errors will be return for each `null` items.
//   Queries:
//     - Single item queries will return `null` with no errors.
//     - Many item queries will filter out those items which have access denied, with no errors.
//     - Count queries will only count those items for which access is not denied, with no errors.
//
export type ListAccessControl<ListTypeInfo extends BaseListTypeInfo> = {
  // These functions should return `true` if access is allowed or `false` if access is denied.
  operation?: {
    query?: OperationAccessControl<'query', ListTypeInfo>;
    create?: OperationAccessControl<'create', ListTypeInfo>;
    update?: OperationAccessControl<'update', ListTypeInfo>;
    delete?: OperationAccessControl<'delete', ListTypeInfo>;
  };

  // The 'filter' rules can return either:
  // - a filter. In this case, the operation can proceed, but the filter will be additionally applied when updating/reading/deleting
  //   which may make it appear that some of the items don't exist.
  // - boolean true/false. If false, treated as a filter that never matches.
  filter?: {
    query?: FilterAccessControl<'query', ListTypeInfo>;
    update?: FilterAccessControl<'update', ListTypeInfo>;
    delete?: FilterAccessControl<'delete', ListTypeInfo>;
    // create: not supported: FIXME: Add explicit check that people don't try this.
    // FIXME: Write tests for parseAccessControl.
  };

  // These rules are applied to each item being operated on individually. They return `true` or `false`,
  // and if false, an access denied error will be returned for the individual operation.
  item?: {
    // query: not supported
    create?: CreateItemAccessControl<ListTypeInfo>;
    update?: UpdateItemAccessControl<ListTypeInfo>;
    delete?: DeleteItemAccessControl<ListTypeInfo>;
  };
};

// Field Access
export type IndividualFieldAccessControl<Args> = (args: Args) => MaybePromise<boolean>;

export type FieldCreateItemAccessArgs<ModelTypeInfo extends BaseModelTypeInfo> =
  CreateItemAccessArgs<ModelTypeInfo> & { fieldKey: string };

export type FieldReadItemAccessArgs<ModelTypeInfo extends BaseModelTypeInfo> =
  BaseAccessArgs<ModelTypeInfo> & {
    operation: 'read';
    fieldKey: string;
    item: ModelTypeInfo['item'];
  };

export type FieldUpdateItemAccessArgs<ModelTypeInfo extends BaseModelTypeInfo> =
  UpdateItemAccessArgs<ModelTypeInfo> & { fieldKey: string };

export type FieldAccessControl<ModelTypeInfo extends BaseModelTypeInfo> =
  | {
      read?: IndividualFieldAccessControl<FieldReadItemAccessArgs<ModelTypeInfo>>;
      create?: IndividualFieldAccessControl<FieldCreateItemAccessArgs<ModelTypeInfo>>;
      update?: IndividualFieldAccessControl<FieldUpdateItemAccessArgs<ModelTypeInfo>>;
    }
  | IndividualFieldAccessControl<
      | FieldCreateItemAccessArgs<ModelTypeInfo>
      | FieldReadItemAccessArgs<ModelTypeInfo>
      | FieldUpdateItemAccessArgs<ModelTypeInfo>
    >;
