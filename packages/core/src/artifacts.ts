import type { ChildProcess } from 'node:child_process'
import fs from 'node:fs/promises'
import path from 'node:path'

import { printSchema } from 'graphql'
import { defaultRegistry } from '@prisma/client-generator-registry'
import {
  getGenerators,
  formatSchema,
  getSchemaWithPath,
  processSchemaResult,
} from '@prisma/internals'

import { printPrismaSchema } from './lib/core/prisma-schema-printer'
import type { System } from './lib/system'
import { printGeneratedTypes } from './lib/typescript-schema-printer'

export function getFormattedGraphQLSchema(schema: string) {
  return (
    '# This file is automatically generated by Keystone, do not modify it manually.\n' +
    '# Modify your Keystone config when you want to change this.\n\n' +
    schema +
    '\n'
  )
}

async function readFileOrUndefined(path: string) {
  try {
    return await fs.readFile(path, 'utf8')
  } catch (err: any) {
    if (err.code === 'ENOENT') return
    throw err
  }
}

export async function validateArtifacts(cwd: string, system: System) {
  const paths = system.getPaths(cwd)
  const artifacts = await buildArtifacts(system)
  const [writtenGraphQLSchema, writtenPrismaSchema] = await Promise.all([
    readFileOrUndefined(paths.schema.graphql),
    readFileOrUndefined(paths.schema.prisma),
  ])

  if (writtenGraphQLSchema !== artifacts.graphql && writtenPrismaSchema !== artifacts.prisma) {
    throw new Error('Your Prisma and GraphQL schemas are not up to date')
  }

  if (writtenGraphQLSchema !== artifacts.graphql) {
    throw new Error('Your GraphQL schema is not up to date')
  }

  if (writtenPrismaSchema !== artifacts.prisma) {
    throw new Error('Your Prisma schema is not up to date')
  }
}

// exported for tests
export async function buildArtifacts(system: System) {
  const prismaSchema = await formatSchema({
    schemas: [[system.config.db.prismaSchemaPath, printPrismaSchema(system.config, system.lists)]],
  })

  return {
    graphql: getFormattedGraphQLSchema(printSchema(system.graphQLSchema)),
    prisma: prismaSchema[0][1],
  }
}

export async function generateArtifacts(cwd: string, system: System) {
  const paths = system.getPaths(cwd)
  const artifacts = await buildArtifacts(system)
  await fs.writeFile(paths.schema.graphql, artifacts.graphql)
  await fs.writeFile(paths.schema.prisma, artifacts.prisma)
  return artifacts
}

export async function generateTypes(cwd: string, system: System) {
  const paths = system.getPaths(cwd)
  const schema = printGeneratedTypes(
    paths.types.relativePrismaPath,
    system.graphQLSchemaSudo,
    system.lists
  )
  await fs.mkdir(path.dirname(paths.schema.types), { recursive: true })
  await fs.writeFile(paths.schema.types, schema)
}

export async function generatePrismaClient(cwd: string, system: System) {
  const paths = system.getPaths(cwd)
  const schemaResult = await getSchemaWithPath(paths.schema.prisma, undefined, { cwd })
  const schemaContext = await processSchemaResult({ schemaResult, ignoreEnvVarErrors: true })

  const generators = await getGenerators({
    schemaContext,
    registry: defaultRegistry.toInternal(),
    postinstall: false,
    printDownloadProgress: false,
  })

  console.error(generators)
  await Promise.all(
    generators.map(async generator => {
      try {
        await generator.generate()
      } finally {
        generator.stop()
      }
    })
  )
}
