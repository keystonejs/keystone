// Do not manually modify this file, it is automatically generated by the package at /prisma-utils in this repo.

import { g } from '../../../types/schema'

import { QueryMode } from '../../../types/next-fields'

type StringNullableFilterType = g.InputObjectType<{
  equals: g.Arg<typeof g.String> // can be null
  in: g.Arg<g.ListType<g.NonNullType<typeof g.String>>> // can be null
  notIn: g.Arg<g.ListType<g.NonNullType<typeof g.String>>> // can be null
  lt: g.Arg<typeof g.String>
  lte: g.Arg<typeof g.String>
  gt: g.Arg<typeof g.String>
  gte: g.Arg<typeof g.String>
  contains: g.Arg<typeof g.String>
  startsWith: g.Arg<typeof g.String>
  endsWith: g.Arg<typeof g.String>
  mode: g.Arg<typeof QueryMode>
  not: g.Arg<StringNullableFilterType> // can be null
}>

const StringNullableFilter: StringNullableFilterType = g.inputObject({
  name: 'StringNullableFilter',
  fields: () => ({
    equals: g.arg({ type: g.String }), // can be null
    in: g.arg({ type: g.list(g.nonNull(g.String)) }), // can be null
    notIn: g.arg({ type: g.list(g.nonNull(g.String)) }), // can be null
    lt: g.arg({ type: g.String }),
    lte: g.arg({ type: g.String }),
    gt: g.arg({ type: g.String }),
    gte: g.arg({ type: g.String }),
    contains: g.arg({ type: g.String }),
    startsWith: g.arg({ type: g.String }),
    endsWith: g.arg({ type: g.String }),
    mode: g.arg({ type: QueryMode }),
    not: g.arg({ type: StringNullableFilter }), // can be null
  }),
})

type StringFilterType = g.InputObjectType<{
  equals: g.Arg<typeof g.String>
  in: g.Arg<g.ListType<g.NonNullType<typeof g.String>>>
  notIn: g.Arg<g.ListType<g.NonNullType<typeof g.String>>>
  lt: g.Arg<typeof g.String>
  lte: g.Arg<typeof g.String>
  gt: g.Arg<typeof g.String>
  gte: g.Arg<typeof g.String>
  contains: g.Arg<typeof g.String>
  startsWith: g.Arg<typeof g.String>
  endsWith: g.Arg<typeof g.String>
  mode: g.Arg<typeof QueryMode>
  not: g.Arg<NestedStringFilterType>
}>

const StringFilter: StringFilterType = g.inputObject({
  name: 'StringFilter',
  fields: () => ({
    equals: g.arg({ type: g.String }),
    in: g.arg({ type: g.list(g.nonNull(g.String)) }),
    notIn: g.arg({ type: g.list(g.nonNull(g.String)) }),
    lt: g.arg({ type: g.String }),
    lte: g.arg({ type: g.String }),
    gt: g.arg({ type: g.String }),
    gte: g.arg({ type: g.String }),
    contains: g.arg({ type: g.String }),
    startsWith: g.arg({ type: g.String }),
    endsWith: g.arg({ type: g.String }),
    mode: g.arg({ type: QueryMode }),
    not: g.arg({ type: NestedStringFilter }),
  }),
})

type NestedStringNullableFilterType = g.InputObjectType<{
  equals: g.Arg<typeof g.String> // can be null
  in: g.Arg<g.ListType<g.NonNullType<typeof g.String>>> // can be null
  notIn: g.Arg<g.ListType<g.NonNullType<typeof g.String>>> // can be null
  lt: g.Arg<typeof g.String>
  lte: g.Arg<typeof g.String>
  gt: g.Arg<typeof g.String>
  gte: g.Arg<typeof g.String>
  contains: g.Arg<typeof g.String>
  startsWith: g.Arg<typeof g.String>
  endsWith: g.Arg<typeof g.String>
  not: g.Arg<NestedStringNullableFilterType> // can be null
}>

const NestedStringNullableFilter: NestedStringNullableFilterType = g.inputObject({
  name: 'NestedStringNullableFilter',
  fields: () => ({
    equals: g.arg({ type: g.String }), // can be null
    in: g.arg({ type: g.list(g.nonNull(g.String)) }), // can be null
    notIn: g.arg({ type: g.list(g.nonNull(g.String)) }), // can be null
    lt: g.arg({ type: g.String }),
    lte: g.arg({ type: g.String }),
    gt: g.arg({ type: g.String }),
    gte: g.arg({ type: g.String }),
    contains: g.arg({ type: g.String }),
    startsWith: g.arg({ type: g.String }),
    endsWith: g.arg({ type: g.String }),
    not: g.arg({ type: NestedStringNullableFilter }), // can be null
  }),
})

type NestedStringFilterType = g.InputObjectType<{
  equals: g.Arg<typeof g.String>
  in: g.Arg<g.ListType<g.NonNullType<typeof g.String>>>
  notIn: g.Arg<g.ListType<g.NonNullType<typeof g.String>>>
  lt: g.Arg<typeof g.String>
  lte: g.Arg<typeof g.String>
  gt: g.Arg<typeof g.String>
  gte: g.Arg<typeof g.String>
  contains: g.Arg<typeof g.String>
  startsWith: g.Arg<typeof g.String>
  endsWith: g.Arg<typeof g.String>
  not: g.Arg<NestedStringFilterType>
}>

const NestedStringFilter: NestedStringFilterType = g.inputObject({
  name: 'NestedStringFilter',
  fields: () => ({
    equals: g.arg({ type: g.String }),
    in: g.arg({ type: g.list(g.nonNull(g.String)) }),
    notIn: g.arg({ type: g.list(g.nonNull(g.String)) }),
    lt: g.arg({ type: g.String }),
    lte: g.arg({ type: g.String }),
    gt: g.arg({ type: g.String }),
    gte: g.arg({ type: g.String }),
    contains: g.arg({ type: g.String }),
    startsWith: g.arg({ type: g.String }),
    endsWith: g.arg({ type: g.String }),
    not: g.arg({ type: NestedStringFilter }),
  }),
})

type BooleanNullableFilterType = g.InputObjectType<{
  equals: g.Arg<typeof g.Boolean> // can be null
  not: g.Arg<BooleanNullableFilterType> // can be null
}>

const BooleanNullableFilter: BooleanNullableFilterType = g.inputObject({
  name: 'BooleanNullableFilter',
  fields: () => ({
    equals: g.arg({ type: g.Boolean }), // can be null
    not: g.arg({ type: BooleanNullableFilter }), // can be null
  }),
})

type BooleanFilterType = g.InputObjectType<{
  equals: g.Arg<typeof g.Boolean>
  not: g.Arg<BooleanFilterType>
}>

const BooleanFilter: BooleanFilterType = g.inputObject({
  name: 'BooleanFilter',
  fields: () => ({
    equals: g.arg({ type: g.Boolean }),
    not: g.arg({ type: BooleanFilter }),
  }),
})

type IntFilterType = g.InputObjectType<{
  equals: g.Arg<typeof g.Int>
  in: g.Arg<g.ListType<g.NonNullType<typeof g.Int>>>
  notIn: g.Arg<g.ListType<g.NonNullType<typeof g.Int>>>
  lt: g.Arg<typeof g.Int>
  lte: g.Arg<typeof g.Int>
  gt: g.Arg<typeof g.Int>
  gte: g.Arg<typeof g.Int>
  not: g.Arg<IntFilterType>
}>

const IntFilter: IntFilterType = g.inputObject({
  name: 'IntFilter',
  fields: () => ({
    equals: g.arg({ type: g.Int }),
    in: g.arg({ type: g.list(g.nonNull(g.Int)) }),
    notIn: g.arg({ type: g.list(g.nonNull(g.Int)) }),
    lt: g.arg({ type: g.Int }),
    lte: g.arg({ type: g.Int }),
    gt: g.arg({ type: g.Int }),
    gte: g.arg({ type: g.Int }),
    not: g.arg({ type: IntFilter }),
  }),
})

type IntNullableFilterType = g.InputObjectType<{
  equals: g.Arg<typeof g.Int> // can be null
  in: g.Arg<g.ListType<g.NonNullType<typeof g.Int>>> // can be null
  notIn: g.Arg<g.ListType<g.NonNullType<typeof g.Int>>> // can be null
  lt: g.Arg<typeof g.Int>
  lte: g.Arg<typeof g.Int>
  gt: g.Arg<typeof g.Int>
  gte: g.Arg<typeof g.Int>
  not: g.Arg<IntNullableFilterType> // can be null
}>

const IntNullableFilter: IntNullableFilterType = g.inputObject({
  name: 'IntNullableFilter',
  fields: () => ({
    equals: g.arg({ type: g.Int }), // can be null
    in: g.arg({ type: g.list(g.nonNull(g.Int)) }), // can be null
    notIn: g.arg({ type: g.list(g.nonNull(g.Int)) }), // can be null
    lt: g.arg({ type: g.Int }),
    lte: g.arg({ type: g.Int }),
    gt: g.arg({ type: g.Int }),
    gte: g.arg({ type: g.Int }),
    not: g.arg({ type: IntNullableFilter }), // can be null
  }),
})

type FloatNullableFilterType = g.InputObjectType<{
  equals: g.Arg<typeof g.Float> // can be null
  in: g.Arg<g.ListType<g.NonNullType<typeof g.Float>>> // can be null
  notIn: g.Arg<g.ListType<g.NonNullType<typeof g.Float>>> // can be null
  lt: g.Arg<typeof g.Float>
  lte: g.Arg<typeof g.Float>
  gt: g.Arg<typeof g.Float>
  gte: g.Arg<typeof g.Float>
  not: g.Arg<FloatNullableFilterType> // can be null
}>

const FloatNullableFilter: FloatNullableFilterType = g.inputObject({
  name: 'FloatNullableFilter',
  fields: () => ({
    equals: g.arg({ type: g.Float }), // can be null
    in: g.arg({ type: g.list(g.nonNull(g.Float)) }), // can be null
    notIn: g.arg({ type: g.list(g.nonNull(g.Float)) }), // can be null
    lt: g.arg({ type: g.Float }),
    lte: g.arg({ type: g.Float }),
    gt: g.arg({ type: g.Float }),
    gte: g.arg({ type: g.Float }),
    not: g.arg({ type: FloatNullableFilter }), // can be null
  }),
})

type FloatFilterType = g.InputObjectType<{
  equals: g.Arg<typeof g.Float>
  in: g.Arg<g.ListType<g.NonNullType<typeof g.Float>>>
  notIn: g.Arg<g.ListType<g.NonNullType<typeof g.Float>>>
  lt: g.Arg<typeof g.Float>
  lte: g.Arg<typeof g.Float>
  gt: g.Arg<typeof g.Float>
  gte: g.Arg<typeof g.Float>
  not: g.Arg<FloatFilterType>
}>

const FloatFilter: FloatFilterType = g.inputObject({
  name: 'FloatFilter',
  fields: () => ({
    equals: g.arg({ type: g.Float }),
    in: g.arg({ type: g.list(g.nonNull(g.Float)) }),
    notIn: g.arg({ type: g.list(g.nonNull(g.Float)) }),
    lt: g.arg({ type: g.Float }),
    lte: g.arg({ type: g.Float }),
    gt: g.arg({ type: g.Float }),
    gte: g.arg({ type: g.Float }),
    not: g.arg({ type: FloatFilter }),
  }),
})

type DateTimeNullableFilterType = g.InputObjectType<{
  equals: g.Arg<typeof g.DateTime> // can be null
  in: g.Arg<g.ListType<g.NonNullType<typeof g.DateTime>>> // can be null
  notIn: g.Arg<g.ListType<g.NonNullType<typeof g.DateTime>>> // can be null
  lt: g.Arg<typeof g.DateTime>
  lte: g.Arg<typeof g.DateTime>
  gt: g.Arg<typeof g.DateTime>
  gte: g.Arg<typeof g.DateTime>
  not: g.Arg<DateTimeNullableFilterType> // can be null
}>

const DateTimeNullableFilter: DateTimeNullableFilterType = g.inputObject({
  name: 'DateTimeNullableFilter',
  fields: () => ({
    equals: g.arg({ type: g.DateTime }), // can be null
    in: g.arg({ type: g.list(g.nonNull(g.DateTime)) }), // can be null
    notIn: g.arg({ type: g.list(g.nonNull(g.DateTime)) }), // can be null
    lt: g.arg({ type: g.DateTime }),
    lte: g.arg({ type: g.DateTime }),
    gt: g.arg({ type: g.DateTime }),
    gte: g.arg({ type: g.DateTime }),
    not: g.arg({ type: DateTimeNullableFilter }), // can be null
  }),
})

type DateTimeFilterType = g.InputObjectType<{
  equals: g.Arg<typeof g.DateTime>
  in: g.Arg<g.ListType<g.NonNullType<typeof g.DateTime>>>
  notIn: g.Arg<g.ListType<g.NonNullType<typeof g.DateTime>>>
  lt: g.Arg<typeof g.DateTime>
  lte: g.Arg<typeof g.DateTime>
  gt: g.Arg<typeof g.DateTime>
  gte: g.Arg<typeof g.DateTime>
  not: g.Arg<DateTimeFilterType>
}>

const DateTimeFilter: DateTimeFilterType = g.inputObject({
  name: 'DateTimeFilter',
  fields: () => ({
    equals: g.arg({ type: g.DateTime }),
    in: g.arg({ type: g.list(g.nonNull(g.DateTime)) }),
    notIn: g.arg({ type: g.list(g.nonNull(g.DateTime)) }),
    lt: g.arg({ type: g.DateTime }),
    lte: g.arg({ type: g.DateTime }),
    gt: g.arg({ type: g.DateTime }),
    gte: g.arg({ type: g.DateTime }),
    not: g.arg({ type: DateTimeFilter }),
  }),
})

type DecimalNullableFilterType = g.InputObjectType<{
  equals: g.Arg<typeof g.Decimal> // can be null
  in: g.Arg<g.ListType<g.NonNullType<typeof g.Decimal>>> // can be null
  notIn: g.Arg<g.ListType<g.NonNullType<typeof g.Decimal>>> // can be null
  lt: g.Arg<typeof g.Decimal>
  lte: g.Arg<typeof g.Decimal>
  gt: g.Arg<typeof g.Decimal>
  gte: g.Arg<typeof g.Decimal>
  not: g.Arg<DecimalNullableFilterType> // can be null
}>

const DecimalNullableFilter: DecimalNullableFilterType = g.inputObject({
  name: 'DecimalNullableFilter',
  fields: () => ({
    equals: g.arg({ type: g.Decimal }), // can be null
    in: g.arg({ type: g.list(g.nonNull(g.Decimal)) }), // can be null
    notIn: g.arg({ type: g.list(g.nonNull(g.Decimal)) }), // can be null
    lt: g.arg({ type: g.Decimal }),
    lte: g.arg({ type: g.Decimal }),
    gt: g.arg({ type: g.Decimal }),
    gte: g.arg({ type: g.Decimal }),
    not: g.arg({ type: DecimalNullableFilter }), // can be null
  }),
})

type DecimalFilterType = g.InputObjectType<{
  equals: g.Arg<typeof g.Decimal>
  in: g.Arg<g.ListType<g.NonNullType<typeof g.Decimal>>>
  notIn: g.Arg<g.ListType<g.NonNullType<typeof g.Decimal>>>
  lt: g.Arg<typeof g.Decimal>
  lte: g.Arg<typeof g.Decimal>
  gt: g.Arg<typeof g.Decimal>
  gte: g.Arg<typeof g.Decimal>
  not: g.Arg<DecimalFilterType>
}>

const DecimalFilter: DecimalFilterType = g.inputObject({
  name: 'DecimalFilter',
  fields: () => ({
    equals: g.arg({ type: g.Decimal }),
    in: g.arg({ type: g.list(g.nonNull(g.Decimal)) }),
    notIn: g.arg({ type: g.list(g.nonNull(g.Decimal)) }),
    lt: g.arg({ type: g.Decimal }),
    lte: g.arg({ type: g.Decimal }),
    gt: g.arg({ type: g.Decimal }),
    gte: g.arg({ type: g.Decimal }),
    not: g.arg({ type: DecimalFilter }),
  }),
})

type BigIntNullableFilterType = g.InputObjectType<{
  equals: g.Arg<typeof g.BigInt> // can be null
  in: g.Arg<g.ListType<g.NonNullType<typeof g.BigInt>>> // can be null
  notIn: g.Arg<g.ListType<g.NonNullType<typeof g.BigInt>>> // can be null
  lt: g.Arg<typeof g.BigInt>
  lte: g.Arg<typeof g.BigInt>
  gt: g.Arg<typeof g.BigInt>
  gte: g.Arg<typeof g.BigInt>
  not: g.Arg<BigIntNullableFilterType> // can be null
}>

const BigIntNullableFilter: BigIntNullableFilterType = g.inputObject({
  name: 'BigIntNullableFilter',
  fields: () => ({
    equals: g.arg({ type: g.BigInt }), // can be null
    in: g.arg({ type: g.list(g.nonNull(g.BigInt)) }), // can be null
    notIn: g.arg({ type: g.list(g.nonNull(g.BigInt)) }), // can be null
    lt: g.arg({ type: g.BigInt }),
    lte: g.arg({ type: g.BigInt }),
    gt: g.arg({ type: g.BigInt }),
    gte: g.arg({ type: g.BigInt }),
    not: g.arg({ type: BigIntNullableFilter }), // can be null
  }),
})

type BigIntFilterType = g.InputObjectType<{
  equals: g.Arg<typeof g.BigInt>
  in: g.Arg<g.ListType<g.NonNullType<typeof g.BigInt>>>
  notIn: g.Arg<g.ListType<g.NonNullType<typeof g.BigInt>>>
  lt: g.Arg<typeof g.BigInt>
  lte: g.Arg<typeof g.BigInt>
  gt: g.Arg<typeof g.BigInt>
  gte: g.Arg<typeof g.BigInt>
  not: g.Arg<BigIntFilterType>
}>

const BigIntFilter: BigIntFilterType = g.inputObject({
  name: 'BigIntFilter',
  fields: () => ({
    equals: g.arg({ type: g.BigInt }),
    in: g.arg({ type: g.list(g.nonNull(g.BigInt)) }),
    notIn: g.arg({ type: g.list(g.nonNull(g.BigInt)) }),
    lt: g.arg({ type: g.BigInt }),
    lte: g.arg({ type: g.BigInt }),
    gt: g.arg({ type: g.BigInt }),
    gte: g.arg({ type: g.BigInt }),
    not: g.arg({ type: BigIntFilter }),
  }),
})

export const String = {
  optional: StringNullableFilter,
  required: StringFilter,
}

export const Boolean = {
  optional: BooleanNullableFilter,
  required: BooleanFilter,
}

export const Int = {
  optional: IntNullableFilter,
  required: IntFilter,
}

export const Float = {
  optional: FloatNullableFilter,
  required: FloatFilter,
}

export const DateTime = {
  optional: DateTimeNullableFilter,
  required: DateTimeFilter,
}

export const Decimal = {
  optional: DecimalNullableFilter,
  required: DecimalFilter,
}

export const BigInt = {
  optional: BigIntNullableFilter,
  required: BigIntFilter,
}

export { enumFilters as enum } from '../enum-filter'
